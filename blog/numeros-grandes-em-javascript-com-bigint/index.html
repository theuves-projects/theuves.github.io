<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/9db2b6f97fa9938b776a.css" as="style"/><link rel="stylesheet" href="/_next/static/css/9db2b6f97fa9938b776a.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-12c069fcb26ee750200e.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.abffcf18e526b7c0dbcd.js" as="script"/><link rel="preload" href="/_next/static/chunks/1b1d2efccfda2790dd424b9455d4bf69d97f9eaa.10b20fed2722a467a0a9.js" as="script"/><link rel="preload" href="/_next/static/chunks/f6078781a05fe1bcb0902d23dbbb2662c8d200b3.22385a4a605b66265c77.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-98df5063b029dd539922.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/blog/%5Bpost%5D-27b6e4167a38e98f672f.js" as="script"/><style id="__jsx-2983921491">.header.jsx-2983921491{text-align:center;padding:calc(var(--margin) / 2) 0;margin-bottom:var(--margin);border-bottom:solid 1px black;}.header-title.jsx-2983921491{margin-bottom:0;display:inline-block;font-size:2em;line-height:175%;-webkit-text-decoration:none;text-decoration:none;color:black;font-weight:bold;}.header-title.jsx-2983921491:hover{color:#333;}.header-list.jsx-2983921491{padding-left:0;}.header-item.jsx-2983921491{display:inline-block;}.header-item.jsx-2983921491:not(:first-child){margin-left:10px;}.header-item.jsx-2983921491:not(:last-child){margin-right:10px;}.header-link.jsx-2983921491{text-transform:uppercase;-webkit-text-decoration:none;text-decoration:none;font-size:.9em;color:black;}.header-external.jsx-2983921491{width:.8em;color:#666;}.header-link.jsx-2983921491:hover{color:#666;}</style><style id="__jsx-3051481630">.metadata.jsx-3051481630{color:#333;font-style:italic;text-align:right;font-size:14px;}.author.jsx-3051481630{color:#333;text-align:right;font-size:14px;}</style><style id="__jsx-1823023501">.main.jsx-1823023501{max-width:600px;margin:0 auto;}</style></head><body><div id="__next"><title>Matheus Alves (@theuves)</title><header class="jsx-2983921491 header"><a href="/" class="jsx-2983921491 header-title">Matheus Alves</a><ul class="jsx-2983921491 header-list"><li class="jsx-2983921491 header-item"><a href="/" class="jsx-2983921491 header-link">Início</a></li><li class="jsx-2983921491 header-item"><a href="/projects" class="jsx-2983921491 header-link">Projetos</a></li><li class="jsx-2983921491 header-item"><a target="_blank" href="https://github.com/theuves" class="jsx-2983921491 header-link">GitHub <img src="/external-link.svg" class="jsx-2983921491 header-external"/></a></li><li class="jsx-2983921491 header-item"><a target="_blank" href="https://www.linkedin.com/in/theuves/" class="jsx-2983921491 header-link">LinkedIn <img src="/external-link.svg" class="jsx-2983921491 header-external"/></a></li></ul></header><div class="jsx-1823023501 main"><div class="jsx-3051481630 metadata"><span class="jsx-3051481630">Matheus Alves / <!-- -->12/16/2018</span></div><h1 class="jsx-3051481630 title">Números grandes em JavaScript com BigInt</h1><article class="jsx-3051481630 article"><div><p>Certa vez, quando comecei estudar JavaScript, decidi criar uma
<a href="https://github.com/theuves/extenso.js">ferramenta para escrever números por extenso</a>
na língua portuguesa. Tal ferramenta deveria escrever valores altos: até 999
decilhões.</p><p>No entanto, enfrentei problemas logo quando tentei realizar os testes
unitários, onde em um momento, eu passava <code>10000000000000001</code> (em <code>Number</code>)
como entrada e esperava ter, portanto, <code>&#x27;dez quatrilhões e um&#x27;</code> como saída. Mas
tinha algo errado e eu só recebia <code>&#x27;dez quatrilhões&#x27;</code>. Revirei todo o meu
código a procura do erro, mas só após um bom tempo descobri que o &quot;problema&quot;
estava fora dele: no próprio JavaScript.</p><p>O fato é que a linguagem armazena os seus valores numéricos em 64 bits seguindo
o <a href="https://www.youtube.com/watch?v=PDgT0T0Yodo">padrão internacional IEEE 754</a>
cujo o maior número inteiro com uma precisão segura é 9.007.199.254.740.991
(cerca de 9 quatrilhões), onde qualquer número maior que esse pode ter valores
perdidos, sendo assim, inseguros. Visto que nos meus testes eu estava passando
um valor maior que esse e como um <code>Number</code> do JavaScript, eu tinha finalmente
encontrado o motivo do erro.</p><h2>Resolvendo o problema com <code>BigInt</code></h2><p>Okay, então não podemos confiar em operações matemáticas com números grandes
no JavaScript pois eles serão registrados de modo diferente? Sim, mas só por
enquanto. Na época em que eu estava fazendo minha ferramenta, não existia
nenhuma proposta de solução para isso, além de bibliotecas que deixam o sistema
lento e o desenvolvimento chato. Até que
<a href="https://twitter.com/littledan">Daniel Ehrenberg</a> publicou sua proposta de
<code>BigInt</code>, um novo tipo de dado que tem como objetivo dar a possibilidade de
manipular números grandes.</p><p>A ideia é simples: representar números inteiros de qualquer tamanho utilizando
um <code>n</code> no final ou dentro de <em>strings</em> envolvidas no objeto <code>BigInt</code>. Sendo
assim, se antes <code>10000000000000001</code> estranhamente virava  <code>10000000000000000</code>,
agora bastaria usar <code>10000000000000001n</code> e o número não teria nenhuma alteração.</p><h2>Funcionamento</h2><p>O <code>BigInt</code> tem o seu próprio tipo, onde <code>typeof 42n</code> é <code>&#x27;bigint&#x27;</code> e não
<code>&#x27;number&#x27;</code>. </p><p>Os <code>BigInt</code>s são bastante semelhantes aos <code>Number</code>s, podendo ser feita as
mesmas operações matemáticas com <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, etc. Contudo, embora eles
sejam parecidos, operações entre um e outro é completamente impossível, o que
significa que você jamais poderá fazer coisas como <code>6n * 2</code>, pois isso causaria
um <code>TypeError</code>. Além disso, assim como o próprio nome <code>BigInt</code> sugere, o novo
tipo só pode trabalhar com números inteiros, onde qualquer resultado quebrado
em operações será arredondado automaticamente.</p><pre><code class="language-js">console.log(5n / 2n) // Isso retorna 2n e não 2.5n.
</code></pre><p>Observa-se também que <code>2.5n</code> não existe, sendo um <code>SyntaxError</code>.</p><p>Outra  semelhança interessante com o <code>Number</code> é a possibilidade da manipulação
de números como se fossem valores booleanos, por exemplo, <code>Boolean(0n)</code> quem é
igual a <code>false</code>, enquanto qualquer outro número diferente de zero é verdadeiro.</p><h2>Já posso usá-lo em projetos?</h2><p>No momento (final de 2018) a proposta do <code>BigInt</code> já está no estágio três,
precisando estar no quatro para ser um novo padrão da linguagem (veja
<a href="https://medium.com/@brunovincius/processo-de-adi%C3%A7%C3%A3o-de-novas-features-do-js-5c2e086cab8f">esse post</a>
do Bruno Vinícius sobre os estágios das futuras características do JavaScript),
mas falta muito pouco para que ele chegue lá, portanto, provavelmente em 2019
ou 2020 ele já estará padronizado.</p><p>Caso você já queira testá-lo na prática, pode fazê-lo com as últimas versões do
Google Chrome (que o aceita
<a href="https://developers.google.com/web/updates/2018/05/nic67">desde maio desse ano</a>),
do Opera e do Node.js. No momento o Mozilla Firefox ainda não o suporta, mas é
possível que em breve também vai aceitá-lo.
<a href="https://caniuse.com/#feat=bigint">Veja aqui como anda a compatibilidade em navegadores da <em>internet</em></a>.</p><p>Como ele ainda é muito pouco suportado, caso você queira trabalhar com número
grandes em algum projeto, o mais recomendado seria usar algum
<a href="https://pt.stackoverflow.com/questions/194857/o-que-%C3%A9-polyfill"><em>polyfill</em></a>.
Há muito tempo já existe bibliotecas como <a href="https://www.npmjs.com/package/bn.js"><em>bn.js</em></a>
que trabalham com métodos para fazer operações com números desse tipo dentro
de <em>strings</em>, porém, elas são lentas e impossibilitam o uso da notação <code>n</code> no
final dos números, o que torna o desenvolvimento desagradável.</p><p>A biblioteca mais interessante no momento é a
<a href="https://www.npmjs.com/package/jsbi"><em>JSBI</em></a> lançada há pouco tempo pela galera
do Google Chrome Labs. Ela basicamente oferece um objeto que pode ser usado
para fazer todas operações que o <code>BigInt</code> poderá fazer.</p><pre><code class="language-js">import JSBI from &#x27;jsbi&#x27;

const x = JSBI.BigInt(&#x27;10000000000000000&#x27;)
const y = JSBI.BigInt(&#x27;1&#x27;)
const result = JSBI.add(x, y)

console.log(result.toString()) // Meu &#x27;10000000000000001&#x27;, finalmente!
</code></pre><p>O mais curioso também, é o <em>plugin</em>
<a href="https://www.npmjs.com/package/babel-plugin-transform-jsbi-to-bigint"><em>babel-plugin-transform-jsbi-to-bigint</em></a>
para o Babel que foi lançado junto com essa biblioteca. Esse <em>plugin</em> permite
que em futuro próximo, quando <code>BigInt</code>s forem nativas do JavaScript, você possa
converter o seu código que faz operações com <em>JSBI</em> para <em>BigInt</em>, ou seja,
<code>JSBI.BigInt(&#x27;10000000000000000&#x27;)</code> seria transformado em <code>10000000000000000n</code>.
Caso queira testar isso, eu deixei
<a href="https://github.com/theuves-demos/jsbi-to-bigint">esse repositório</a> no GitHub
com um exemplo.</p><p>Se você deseja saber mais sobre o funcionamento dessa nova <em>feature</em>, eu
recomendo que você veja a
<a href="https://github.com/tc39/proposal-bigint">proposta dela no GitHub</a> (em inglês)
e assista a palestra
<a href="https://www.youtube.com/watch?v=RiU5OzMZ7z8"><em>Native BigInts in JavaScript: A Case Study in TC39</em></a>
(em inglês também) do próprio autor Daniel Ehrenberg na JSConf 2018.</p></div></article></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"source":{"compiledSource":"\"use strict\";\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i \u003c arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i \u003c sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) \u003e= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i \u003c sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) \u003e= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\n\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Certa vez, quando comecei estudar JavaScript, decidi criar uma\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/theuves/extenso.js\"\n  }), \"ferramenta para escrever n\\xFAmeros por extenso\"), \"\\nna l\\xEDngua portuguesa. Tal ferramenta deveria escrever valores altos: at\\xE9 999\\ndecilh\\xF5es.\"), mdx(\"p\", null, \"No entanto, enfrentei problemas logo quando tentei realizar os testes\\nunit\\xE1rios, onde em um momento, eu passava \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"10000000000000001\"), \" (em \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Number\"), \")\\ncomo entrada e esperava ter, portanto, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"'dez quatrilh\\xF5es e um'\"), \" como sa\\xEDda. Mas\\ntinha algo errado e eu s\\xF3 recebia \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"'dez quatrilh\\xF5es'\"), \". Revirei todo o meu\\nc\\xF3digo a procura do erro, mas s\\xF3 ap\\xF3s um bom tempo descobri que o \\\"problema\\\"\\nestava fora dele: no pr\\xF3prio JavaScript.\"), mdx(\"p\", null, \"O fato \\xE9 que a linguagem armazena os seus valores num\\xE9ricos em 64 bits seguindo\\no \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.youtube.com/watch?v=PDgT0T0Yodo\"\n  }), \"padr\\xE3o internacional IEEE 754\"), \"\\ncujo o maior n\\xFAmero inteiro com uma precis\\xE3o segura \\xE9 9.007.199.254.740.991\\n(cerca de 9 quatrilh\\xF5es), onde qualquer n\\xFAmero maior que esse pode ter valores\\nperdidos, sendo assim, inseguros. Visto que nos meus testes eu estava passando\\num valor maior que esse e como um \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Number\"), \" do JavaScript, eu tinha finalmente\\nencontrado o motivo do erro.\"), mdx(\"h2\", null, \"Resolvendo o problema com \", mdx(\"inlineCode\", {\n    parentName: \"h2\"\n  }, \"BigInt\")), mdx(\"p\", null, \"Okay, ent\\xE3o n\\xE3o podemos confiar em opera\\xE7\\xF5es matem\\xE1ticas com n\\xFAmeros grandes\\nno JavaScript pois eles ser\\xE3o registrados de modo diferente? Sim, mas s\\xF3 por\\nenquanto. Na \\xE9poca em que eu estava fazendo minha ferramenta, n\\xE3o existia\\nnenhuma proposta de solu\\xE7\\xE3o para isso, al\\xE9m de bibliotecas que deixam o sistema\\nlento e o desenvolvimento chato. At\\xE9 que\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://twitter.com/littledan\"\n  }), \"Daniel Ehrenberg\"), \" publicou sua proposta de\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"BigInt\"), \", um novo tipo de dado que tem como objetivo dar a possibilidade de\\nmanipular n\\xFAmeros grandes.\"), mdx(\"p\", null, \"A ideia \\xE9 simples: representar n\\xFAmeros inteiros de qualquer tamanho utilizando\\num \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"n\"), \" no final ou dentro de \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"strings\"), \" envolvidas no objeto \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"BigInt\"), \". Sendo\\nassim, se antes \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"10000000000000001\"), \" estranhamente virava  \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"10000000000000000\"), \",\\nagora bastaria usar \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"10000000000000001n\"), \" e o n\\xFAmero n\\xE3o teria nenhuma altera\\xE7\\xE3o.\"), mdx(\"h2\", null, \"Funcionamento\"), mdx(\"p\", null, \"O \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"BigInt\"), \" tem o seu pr\\xF3prio tipo, onde \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"typeof 42n\"), \" \\xE9 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"'bigint'\"), \" e n\\xE3o\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"'number'\"), \". \"), mdx(\"p\", null, \"Os \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"BigInt\"), \"s s\\xE3o bastante semelhantes aos \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Number\"), \"s, podendo ser feita as\\nmesmas opera\\xE7\\xF5es matem\\xE1ticas com \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"+\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"-\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"*\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"/\"), \", etc. Contudo, embora eles\\nsejam parecidos, opera\\xE7\\xF5es entre um e outro \\xE9 completamente imposs\\xEDvel, o que\\nsignifica que voc\\xEA jamais poder\\xE1 fazer coisas como \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"6n * 2\"), \", pois isso causaria\\num \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TypeError\"), \". Al\\xE9m disso, assim como o pr\\xF3prio nome \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"BigInt\"), \" sugere, o novo\\ntipo s\\xF3 pode trabalhar com n\\xFAmeros inteiros, onde qualquer resultado quebrado\\nem opera\\xE7\\xF5es ser\\xE1 arredondado automaticamente.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"console.log(5n / 2n) // Isso retorna 2n e n\\xE3o 2.5n.\\n\")), mdx(\"p\", null, \"Observa-se tamb\\xE9m que \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"2.5n\"), \" n\\xE3o existe, sendo um \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SyntaxError\"), \".\"), mdx(\"p\", null, \"Outra  semelhan\\xE7a interessante com o \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Number\"), \" \\xE9 a possibilidade da manipula\\xE7\\xE3o\\nde n\\xFAmeros como se fossem valores booleanos, por exemplo, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Boolean(0n)\"), \" quem \\xE9\\nigual a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"false\"), \", enquanto qualquer outro n\\xFAmero diferente de zero \\xE9 verdadeiro.\"), mdx(\"h2\", null, \"J\\xE1 posso us\\xE1-lo em projetos?\"), mdx(\"p\", null, \"No momento (final de 2018) a proposta do \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"BigInt\"), \" j\\xE1 est\\xE1 no est\\xE1gio tr\\xEAs,\\nprecisando estar no quatro para ser um novo padr\\xE3o da linguagem (veja\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://medium.com/@brunovincius/processo-de-adi%C3%A7%C3%A3o-de-novas-features-do-js-5c2e086cab8f\"\n  }), \"esse post\"), \"\\ndo Bruno Vin\\xEDcius sobre os est\\xE1gios das futuras caracter\\xEDsticas do JavaScript),\\nmas falta muito pouco para que ele chegue l\\xE1, portanto, provavelmente em 2019\\nou 2020 ele j\\xE1 estar\\xE1 padronizado.\"), mdx(\"p\", null, \"Caso voc\\xEA j\\xE1 queira test\\xE1-lo na pr\\xE1tica, pode faz\\xEA-lo com as \\xFAltimas vers\\xF5es do\\nGoogle Chrome (que o aceita\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://developers.google.com/web/updates/2018/05/nic67\"\n  }), \"desde maio desse ano\"), \"),\\ndo Opera e do Node.js. No momento o Mozilla Firefox ainda n\\xE3o o suporta, mas \\xE9\\nposs\\xEDvel que em breve tamb\\xE9m vai aceit\\xE1-lo.\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://caniuse.com/#feat=bigint\"\n  }), \"Veja aqui como anda a compatibilidade em navegadores da \", mdx(\"em\", {\n    parentName: \"a\"\n  }, \"internet\")), \".\"), mdx(\"p\", null, \"Como ele ainda \\xE9 muito pouco suportado, caso voc\\xEA queira trabalhar com n\\xFAmero\\ngrandes em algum projeto, o mais recomendado seria usar algum\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://pt.stackoverflow.com/questions/194857/o-que-%C3%A9-polyfill\"\n  }), mdx(\"em\", {\n    parentName: \"a\"\n  }, \"polyfill\")), \".\\nH\\xE1 muito tempo j\\xE1 existe bibliotecas como \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.npmjs.com/package/bn.js\"\n  }), mdx(\"em\", {\n    parentName: \"a\"\n  }, \"bn.js\")), \"\\nque trabalham com m\\xE9todos para fazer opera\\xE7\\xF5es com n\\xFAmeros desse tipo dentro\\nde \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"strings\"), \", por\\xE9m, elas s\\xE3o lentas e impossibilitam o uso da nota\\xE7\\xE3o \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"n\"), \" no\\nfinal dos n\\xFAmeros, o que torna o desenvolvimento desagrad\\xE1vel.\"), mdx(\"p\", null, \"A biblioteca mais interessante no momento \\xE9 a\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.npmjs.com/package/jsbi\"\n  }), mdx(\"em\", {\n    parentName: \"a\"\n  }, \"JSBI\")), \" lan\\xE7ada h\\xE1 pouco tempo pela galera\\ndo Google Chrome Labs. Ela basicamente oferece um objeto que pode ser usado\\npara fazer todas opera\\xE7\\xF5es que o \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"BigInt\"), \" poder\\xE1 fazer.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"import JSBI from 'jsbi'\\n\\nconst x = JSBI.BigInt('10000000000000000')\\nconst y = JSBI.BigInt('1')\\nconst result = JSBI.add(x, y)\\n\\nconsole.log(result.toString()) // Meu '10000000000000001', finalmente!\\n\")), mdx(\"p\", null, \"O mais curioso tamb\\xE9m, \\xE9 o \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"plugin\"), \"\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.npmjs.com/package/babel-plugin-transform-jsbi-to-bigint\"\n  }), mdx(\"em\", {\n    parentName: \"a\"\n  }, \"babel-plugin-transform-jsbi-to-bigint\")), \"\\npara o Babel que foi lan\\xE7ado junto com essa biblioteca. Esse \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"plugin\"), \" permite\\nque em futuro pr\\xF3ximo, quando \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"BigInt\"), \"s forem nativas do JavaScript, voc\\xEA possa\\nconverter o seu c\\xF3digo que faz opera\\xE7\\xF5es com \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"JSBI\"), \" para \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"BigInt\"), \", ou seja,\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"JSBI.BigInt('10000000000000000')\"), \" seria transformado em \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"10000000000000000n\"), \".\\nCaso queira testar isso, eu deixei\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/theuves-demos/jsbi-to-bigint\"\n  }), \"esse reposit\\xF3rio\"), \" no GitHub\\ncom um exemplo.\"), mdx(\"p\", null, \"Se voc\\xEA deseja saber mais sobre o funcionamento dessa nova \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"feature\"), \", eu\\nrecomendo que voc\\xEA veja a\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/tc39/proposal-bigint\"\n  }), \"proposta dela no GitHub\"), \" (em ingl\\xEAs)\\ne assista a palestra\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.youtube.com/watch?v=RiU5OzMZ7z8\"\n  }), mdx(\"em\", {\n    parentName: \"a\"\n  }, \"Native BigInts in JavaScript: A Case Study in TC39\")), \"\\n(em ingl\\xEAs tamb\\xE9m) do pr\\xF3prio autor Daniel Ehrenberg na JSConf 2018.\"));\n}\n\n;\nMDXContent.isMDXComponent = true;","renderedOutput":"\u003cp\u003eCerta vez, quando comecei estudar JavaScript, decidi criar uma\n\u003ca href=\"https://github.com/theuves/extenso.js\"\u003eferramenta para escrever números por extenso\u003c/a\u003e\nna língua portuguesa. Tal ferramenta deveria escrever valores altos: até 999\ndecilhões.\u003c/p\u003e\u003cp\u003eNo entanto, enfrentei problemas logo quando tentei realizar os testes\nunitários, onde em um momento, eu passava \u003ccode\u003e10000000000000001\u003c/code\u003e (em \u003ccode\u003eNumber\u003c/code\u003e)\ncomo entrada e esperava ter, portanto, \u003ccode\u003e\u0026#x27;dez quatrilhões e um\u0026#x27;\u003c/code\u003e como saída. Mas\ntinha algo errado e eu só recebia \u003ccode\u003e\u0026#x27;dez quatrilhões\u0026#x27;\u003c/code\u003e. Revirei todo o meu\ncódigo a procura do erro, mas só após um bom tempo descobri que o \u0026quot;problema\u0026quot;\nestava fora dele: no próprio JavaScript.\u003c/p\u003e\u003cp\u003eO fato é que a linguagem armazena os seus valores numéricos em 64 bits seguindo\no \u003ca href=\"https://www.youtube.com/watch?v=PDgT0T0Yodo\"\u003epadrão internacional IEEE 754\u003c/a\u003e\ncujo o maior número inteiro com uma precisão segura é 9.007.199.254.740.991\n(cerca de 9 quatrilhões), onde qualquer número maior que esse pode ter valores\nperdidos, sendo assim, inseguros. Visto que nos meus testes eu estava passando\num valor maior que esse e como um \u003ccode\u003eNumber\u003c/code\u003e do JavaScript, eu tinha finalmente\nencontrado o motivo do erro.\u003c/p\u003e\u003ch2\u003eResolvendo o problema com \u003ccode\u003eBigInt\u003c/code\u003e\u003c/h2\u003e\u003cp\u003eOkay, então não podemos confiar em operações matemáticas com números grandes\nno JavaScript pois eles serão registrados de modo diferente? Sim, mas só por\nenquanto. Na época em que eu estava fazendo minha ferramenta, não existia\nnenhuma proposta de solução para isso, além de bibliotecas que deixam o sistema\nlento e o desenvolvimento chato. Até que\n\u003ca href=\"https://twitter.com/littledan\"\u003eDaniel Ehrenberg\u003c/a\u003e publicou sua proposta de\n\u003ccode\u003eBigInt\u003c/code\u003e, um novo tipo de dado que tem como objetivo dar a possibilidade de\nmanipular números grandes.\u003c/p\u003e\u003cp\u003eA ideia é simples: representar números inteiros de qualquer tamanho utilizando\num \u003ccode\u003en\u003c/code\u003e no final ou dentro de \u003cem\u003estrings\u003c/em\u003e envolvidas no objeto \u003ccode\u003eBigInt\u003c/code\u003e. Sendo\nassim, se antes \u003ccode\u003e10000000000000001\u003c/code\u003e estranhamente virava  \u003ccode\u003e10000000000000000\u003c/code\u003e,\nagora bastaria usar \u003ccode\u003e10000000000000001n\u003c/code\u003e e o número não teria nenhuma alteração.\u003c/p\u003e\u003ch2\u003eFuncionamento\u003c/h2\u003e\u003cp\u003eO \u003ccode\u003eBigInt\u003c/code\u003e tem o seu próprio tipo, onde \u003ccode\u003etypeof 42n\u003c/code\u003e é \u003ccode\u003e\u0026#x27;bigint\u0026#x27;\u003c/code\u003e e não\n\u003ccode\u003e\u0026#x27;number\u0026#x27;\u003c/code\u003e. \u003c/p\u003e\u003cp\u003eOs \u003ccode\u003eBigInt\u003c/code\u003es são bastante semelhantes aos \u003ccode\u003eNumber\u003c/code\u003es, podendo ser feita as\nmesmas operações matemáticas com \u003ccode\u003e+\u003c/code\u003e, \u003ccode\u003e-\u003c/code\u003e, \u003ccode\u003e*\u003c/code\u003e, \u003ccode\u003e/\u003c/code\u003e, etc. Contudo, embora eles\nsejam parecidos, operações entre um e outro é completamente impossível, o que\nsignifica que você jamais poderá fazer coisas como \u003ccode\u003e6n * 2\u003c/code\u003e, pois isso causaria\num \u003ccode\u003eTypeError\u003c/code\u003e. Além disso, assim como o próprio nome \u003ccode\u003eBigInt\u003c/code\u003e sugere, o novo\ntipo só pode trabalhar com números inteiros, onde qualquer resultado quebrado\nem operações será arredondado automaticamente.\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-js\"\u003econsole.log(5n / 2n) // Isso retorna 2n e não 2.5n.\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eObserva-se também que \u003ccode\u003e2.5n\u003c/code\u003e não existe, sendo um \u003ccode\u003eSyntaxError\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eOutra  semelhança interessante com o \u003ccode\u003eNumber\u003c/code\u003e é a possibilidade da manipulação\nde números como se fossem valores booleanos, por exemplo, \u003ccode\u003eBoolean(0n)\u003c/code\u003e quem é\nigual a \u003ccode\u003efalse\u003c/code\u003e, enquanto qualquer outro número diferente de zero é verdadeiro.\u003c/p\u003e\u003ch2\u003eJá posso usá-lo em projetos?\u003c/h2\u003e\u003cp\u003eNo momento (final de 2018) a proposta do \u003ccode\u003eBigInt\u003c/code\u003e já está no estágio três,\nprecisando estar no quatro para ser um novo padrão da linguagem (veja\n\u003ca href=\"https://medium.com/@brunovincius/processo-de-adi%C3%A7%C3%A3o-de-novas-features-do-js-5c2e086cab8f\"\u003eesse post\u003c/a\u003e\ndo Bruno Vinícius sobre os estágios das futuras características do JavaScript),\nmas falta muito pouco para que ele chegue lá, portanto, provavelmente em 2019\nou 2020 ele já estará padronizado.\u003c/p\u003e\u003cp\u003eCaso você já queira testá-lo na prática, pode fazê-lo com as últimas versões do\nGoogle Chrome (que o aceita\n\u003ca href=\"https://developers.google.com/web/updates/2018/05/nic67\"\u003edesde maio desse ano\u003c/a\u003e),\ndo Opera e do Node.js. No momento o Mozilla Firefox ainda não o suporta, mas é\npossível que em breve também vai aceitá-lo.\n\u003ca href=\"https://caniuse.com/#feat=bigint\"\u003eVeja aqui como anda a compatibilidade em navegadores da \u003cem\u003einternet\u003c/em\u003e\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eComo ele ainda é muito pouco suportado, caso você queira trabalhar com número\ngrandes em algum projeto, o mais recomendado seria usar algum\n\u003ca href=\"https://pt.stackoverflow.com/questions/194857/o-que-%C3%A9-polyfill\"\u003e\u003cem\u003epolyfill\u003c/em\u003e\u003c/a\u003e.\nHá muito tempo já existe bibliotecas como \u003ca href=\"https://www.npmjs.com/package/bn.js\"\u003e\u003cem\u003ebn.js\u003c/em\u003e\u003c/a\u003e\nque trabalham com métodos para fazer operações com números desse tipo dentro\nde \u003cem\u003estrings\u003c/em\u003e, porém, elas são lentas e impossibilitam o uso da notação \u003ccode\u003en\u003c/code\u003e no\nfinal dos números, o que torna o desenvolvimento desagradável.\u003c/p\u003e\u003cp\u003eA biblioteca mais interessante no momento é a\n\u003ca href=\"https://www.npmjs.com/package/jsbi\"\u003e\u003cem\u003eJSBI\u003c/em\u003e\u003c/a\u003e lançada há pouco tempo pela galera\ndo Google Chrome Labs. Ela basicamente oferece um objeto que pode ser usado\npara fazer todas operações que o \u003ccode\u003eBigInt\u003c/code\u003e poderá fazer.\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-js\"\u003eimport JSBI from \u0026#x27;jsbi\u0026#x27;\n\nconst x = JSBI.BigInt(\u0026#x27;10000000000000000\u0026#x27;)\nconst y = JSBI.BigInt(\u0026#x27;1\u0026#x27;)\nconst result = JSBI.add(x, y)\n\nconsole.log(result.toString()) // Meu \u0026#x27;10000000000000001\u0026#x27;, finalmente!\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eO mais curioso também, é o \u003cem\u003eplugin\u003c/em\u003e\n\u003ca href=\"https://www.npmjs.com/package/babel-plugin-transform-jsbi-to-bigint\"\u003e\u003cem\u003ebabel-plugin-transform-jsbi-to-bigint\u003c/em\u003e\u003c/a\u003e\npara o Babel que foi lançado junto com essa biblioteca. Esse \u003cem\u003eplugin\u003c/em\u003e permite\nque em futuro próximo, quando \u003ccode\u003eBigInt\u003c/code\u003es forem nativas do JavaScript, você possa\nconverter o seu código que faz operações com \u003cem\u003eJSBI\u003c/em\u003e para \u003cem\u003eBigInt\u003c/em\u003e, ou seja,\n\u003ccode\u003eJSBI.BigInt(\u0026#x27;10000000000000000\u0026#x27;)\u003c/code\u003e seria transformado em \u003ccode\u003e10000000000000000n\u003c/code\u003e.\nCaso queira testar isso, eu deixei\n\u003ca href=\"https://github.com/theuves-demos/jsbi-to-bigint\"\u003eesse repositório\u003c/a\u003e no GitHub\ncom um exemplo.\u003c/p\u003e\u003cp\u003eSe você deseja saber mais sobre o funcionamento dessa nova \u003cem\u003efeature\u003c/em\u003e, eu\nrecomendo que você veja a\n\u003ca href=\"https://github.com/tc39/proposal-bigint\"\u003eproposta dela no GitHub\u003c/a\u003e (em inglês)\ne assista a palestra\n\u003ca href=\"https://www.youtube.com/watch?v=RiU5OzMZ7z8\"\u003e\u003cem\u003eNative BigInts in JavaScript: A Case Study in TC39\u003c/em\u003e\u003c/a\u003e\n(em inglês também) do próprio autor Daniel Ehrenberg na JSConf 2018.\u003c/p\u003e","scope":{"title":"Números grandes em JavaScript com BigInt","date":"2018-12-16"}},"frontMatter":{"title":"Números grandes em JavaScript com BigInt","date":"2018-12-16"}},"__N_SSG":true},"page":"/blog/[post]","query":{"post":"numeros-grandes-em-javascript-com-bigint"},"buildId":"_Vefdb0nBAV0M8rnMBEiN","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-81bd132d8cf44e5a14d7.js"></script><script src="/_next/static/chunks/main-12c069fcb26ee750200e.js" async=""></script><script src="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" async=""></script><script src="/_next/static/chunks/framework.abffcf18e526b7c0dbcd.js" async=""></script><script src="/_next/static/chunks/1b1d2efccfda2790dd424b9455d4bf69d97f9eaa.10b20fed2722a467a0a9.js" async=""></script><script src="/_next/static/chunks/f6078781a05fe1bcb0902d23dbbb2662c8d200b3.22385a4a605b66265c77.js" async=""></script><script src="/_next/static/chunks/pages/_app-98df5063b029dd539922.js" async=""></script><script src="/_next/static/chunks/pages/blog/%5Bpost%5D-27b6e4167a38e98f672f.js" async=""></script><script src="/_next/static/_Vefdb0nBAV0M8rnMBEiN/_buildManifest.js" async=""></script><script src="/_next/static/_Vefdb0nBAV0M8rnMBEiN/_ssgManifest.js" async=""></script></body></html>