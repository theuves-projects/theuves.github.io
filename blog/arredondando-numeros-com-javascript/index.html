<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/9db2b6f97fa9938b776a.css" as="style"/><link rel="stylesheet" href="/_next/static/css/9db2b6f97fa9938b776a.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-12c069fcb26ee750200e.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.abffcf18e526b7c0dbcd.js" as="script"/><link rel="preload" href="/_next/static/chunks/1b1d2efccfda2790dd424b9455d4bf69d97f9eaa.10b20fed2722a467a0a9.js" as="script"/><link rel="preload" href="/_next/static/chunks/f6078781a05fe1bcb0902d23dbbb2662c8d200b3.22385a4a605b66265c77.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-98df5063b029dd539922.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/blog/%5Bpost%5D-27b6e4167a38e98f672f.js" as="script"/><style id="__jsx-2983921491">.header.jsx-2983921491{text-align:center;padding:calc(var(--margin) / 2) 0;margin-bottom:var(--margin);border-bottom:solid 1px black;}.header-title.jsx-2983921491{margin-bottom:0;display:inline-block;font-size:2em;line-height:175%;-webkit-text-decoration:none;text-decoration:none;color:black;font-weight:bold;}.header-title.jsx-2983921491:hover{color:#333;}.header-list.jsx-2983921491{padding-left:0;}.header-item.jsx-2983921491{display:inline-block;}.header-item.jsx-2983921491:not(:first-child){margin-left:10px;}.header-item.jsx-2983921491:not(:last-child){margin-right:10px;}.header-link.jsx-2983921491{text-transform:uppercase;-webkit-text-decoration:none;text-decoration:none;font-size:.9em;color:black;}.header-external.jsx-2983921491{width:.8em;color:#666;}.header-link.jsx-2983921491:hover{color:#666;}</style><style id="__jsx-3051481630">.metadata.jsx-3051481630{color:#333;font-style:italic;text-align:right;font-size:14px;}.author.jsx-3051481630{color:#333;text-align:right;font-size:14px;}</style><style id="__jsx-1823023501">.main.jsx-1823023501{max-width:600px;margin:0 auto;}</style></head><body><div id="__next"><title>Matheus Alves (@theuves)</title><header class="jsx-2983921491 header"><a href="/" class="jsx-2983921491 header-title">Matheus Alves</a><ul class="jsx-2983921491 header-list"><li class="jsx-2983921491 header-item"><a href="/" class="jsx-2983921491 header-link">Início</a></li><li class="jsx-2983921491 header-item"><a href="/projects" class="jsx-2983921491 header-link">Projetos</a></li><li class="jsx-2983921491 header-item"><a target="_blank" href="https://github.com/theuves" class="jsx-2983921491 header-link">GitHub <img src="/external-link.svg" class="jsx-2983921491 header-external"/></a></li><li class="jsx-2983921491 header-item"><a target="_blank" href="https://www.linkedin.com/in/theuves/" class="jsx-2983921491 header-link">LinkedIn <img src="/external-link.svg" class="jsx-2983921491 header-external"/></a></li></ul></header><div class="jsx-1823023501 main"><div class="jsx-3051481630 metadata"><span class="jsx-3051481630">Matheus Alves / <!-- -->12/17/2018</span></div><h1 class="jsx-3051481630 title">Arredondando números com JavaScript</h1><article class="jsx-3051481630 article"><div><p>O objeto <code>Math</code> do JavaScript possui vários métodos que permitem fazer a
conversão de números decimais, como o <code>floor</code>, o <code>ceil</code> e o <code>round</code>. Logo de
cara, observa-se que todos eles fazem o mesmo serviço: receber valores
decimais e retornar valores inteiros. Por isso acabam confundindo algumas
pessoas, pois eles não são as mesmas funções e, portanto, trabalham de modo
diferente um do outro.</p><p>O funcionamento básico de cada um desses métodos é bem simples: um arredonda
para o inteiro menor, outro para o inteiro maior e outro para o inteiro mais
próximo, respectivamente. Portanto, <code>Math.floor(42.6)</code> é <code>42</code>,
<code>Math.ceil(42.6)</code> é <code>43</code> e <code>Math.round(42.6)</code> é <code>43</code> também. No <code>Math.round</code>,
quando o decimal for <code>0.5</code> o número vai ser arredondado para o maior inteiro
mais próximo.</p><blockquote><p>Observe que <code>Math.floor(3.14)</code> é <code>3</code> e <code>Math.floor(-3.14)</code> é <code>-4</code>.</p></blockquote><h2>Tudo bem, mas e a &quot;parseInt&quot;?</h2><p>Outra função que faz algo parecido com todos esses métodos é a <code>parseInt</code> que
em uma análise rápida se parece muito com o <code>Math.floor</code>. No entanto ela é bem
diferente, pois foi programada para receber strings e não números. Certo, mas
os métodos do objeto <code>Math</code> também convertem <em>strings</em> em objetos, não é? Sim,
mas a <code>parseInt</code> possui algumas características diferentes, por exemplo, ela
analisa somente os dígitos iniciais da <em>string</em>, onde qualquer coisa que vem
depois deles é desconsiderado.</p><pre><code class="language-javascript">parseInt(&#x27;42px&#x27;) // Isso retorna 42
Math.floor(&#x27;42px&#x27;) // Isso retorna NaN :&#x27;-(
</code></pre><h2>Problemas de arredondar com &quot;parseInt&quot;</h2><p>Outra coisa interessante da função <code>parseInt</code> é que ela pode trabalhar como o
inverso do <code>Number.toString</code>, que converte um número para determinada base
numérica (como binário, hexadecimal, entre outros). No caso da <code>parseInt</code>, a
base deve ser informada no segundo argumento do função, por exemplo, &quot;2a&quot; é a
versão hexadecimal do número 42, então se fizermos <code>parseInt(&#x27;2a&#x27;, 16)</code>
(onde <code>16</code> representa &quot;hexadecimal&quot;) vamos obter <code>42</code>.</p><p>Um problema que essa função pode apresentar é em casos em que você queira
arredondar alguns valores que estão dentro <em>arrays</em> utilizando, por exemplo, o
método <code>map</code>. Caso você tenha uma <em>array</em> com <code>42.25</code>, <code>42.5</code> e <code>42.75</code> e queira
tê-los em uma nova <em>array</em> como os valores arredondados para baixo então você
poderia tentar, fracassadamente, isso:</p><pre><code class="language-javascript">[ 42.25, 42.5, 42.75 ].map(parseInt) // Cuidado! Isso retorna [42, NaN, NaN] e não [ 42, 42, 42 ]
</code></pre><p>Nesse caso a <em>callback</em> do método <code>map</code> entrega três parâmetros (o item, o
índice e a própria <em>array</em>), onde nesse caso o índice do segundo argumento do
item que está sendo processado vai entrar em conflito com a base recebida no
segundo argumento do <code>parseInt</code>. Ou seja a <em>array</em> acima seria processada, mais
ou menos da seguinte maneira:</p><pre><code class="language-javascript">[
  parseInt(42.25, 0), // 42.25 = item e 0 = índice
  parseInt(42.5, 1), // 42.5 = item e 1 = índice
  parseInt(42.75, 2) // 42.75 = item e 2 = índice
]
</code></pre><p>Portanto, em casos como esses e em qualquer outro caso no qual você queira
arredondar valores do tipo <code>Number</code>, o mais ideal seria utilizar os métodos do
objeto <code>Math</code>, que nesse caso específico seria o <code>floor</code>.</p></div></article></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"source":{"compiledSource":"\"use strict\";\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i \u003c arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i \u003c sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) \u003e= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i \u003c sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) \u003e= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\n\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"O objeto \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Math\"), \" do JavaScript possui v\\xE1rios m\\xE9todos que permitem fazer a\\nconvers\\xE3o de n\\xFAmeros decimais, como o \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"floor\"), \", o \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ceil\"), \" e o \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"round\"), \". Logo de\\ncara, observa-se que todos eles fazem o mesmo servi\\xE7o: receber valores\\ndecimais e retornar valores inteiros. Por isso acabam confundindo algumas\\npessoas, pois eles n\\xE3o s\\xE3o as mesmas fun\\xE7\\xF5es e, portanto, trabalham de modo\\ndiferente um do outro.\"), mdx(\"p\", null, \"O funcionamento b\\xE1sico de cada um desses m\\xE9todos \\xE9 bem simples: um arredonda\\npara o inteiro menor, outro para o inteiro maior e outro para o inteiro mais\\npr\\xF3ximo, respectivamente. Portanto, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Math.floor(42.6)\"), \" \\xE9 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"42\"), \",\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Math.ceil(42.6)\"), \" \\xE9 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"43\"), \" e \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Math.round(42.6)\"), \" \\xE9 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"43\"), \" tamb\\xE9m. No \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Math.round\"), \",\\nquando o decimal for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0.5\"), \" o n\\xFAmero vai ser arredondado para o maior inteiro\\nmais pr\\xF3ximo.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Observe que \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Math.floor(3.14)\"), \" \\xE9 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"3\"), \" e \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Math.floor(-3.14)\"), \" \\xE9 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"-4\"), \".\")), mdx(\"h2\", null, \"Tudo bem, mas e a \\\"parseInt\\\"?\"), mdx(\"p\", null, \"Outra fun\\xE7\\xE3o que faz algo parecido com todos esses m\\xE9todos \\xE9 a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"parseInt\"), \" que\\nem uma an\\xE1lise r\\xE1pida se parece muito com o \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Math.floor\"), \". No entanto ela \\xE9 bem\\ndiferente, pois foi programada para receber strings e n\\xE3o n\\xFAmeros. Certo, mas\\nos m\\xE9todos do objeto \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Math\"), \" tamb\\xE9m convertem \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"strings\"), \" em objetos, n\\xE3o \\xE9? Sim,\\nmas a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"parseInt\"), \" possui algumas caracter\\xEDsticas diferentes, por exemplo, ela\\nanalisa somente os d\\xEDgitos iniciais da \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"string\"), \", onde qualquer coisa que vem\\ndepois deles \\xE9 desconsiderado.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"parseInt('42px') // Isso retorna 42\\nMath.floor('42px') // Isso retorna NaN :'-(\\n\")), mdx(\"h2\", null, \"Problemas de arredondar com \\\"parseInt\\\"\"), mdx(\"p\", null, \"Outra coisa interessante da fun\\xE7\\xE3o \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"parseInt\"), \" \\xE9 que ela pode trabalhar como o\\ninverso do \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Number.toString\"), \", que converte um n\\xFAmero para determinada base\\nnum\\xE9rica (como bin\\xE1rio, hexadecimal, entre outros). No caso da \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"parseInt\"), \", a\\nbase deve ser informada no segundo argumento do fun\\xE7\\xE3o, por exemplo, \\\"2a\\\" \\xE9 a\\nvers\\xE3o hexadecimal do n\\xFAmero 42, ent\\xE3o se fizermos \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"parseInt('2a', 16)\"), \"\\n(onde \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"16\"), \" representa \\\"hexadecimal\\\") vamos obter \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"42\"), \".\"), mdx(\"p\", null, \"Um problema que essa fun\\xE7\\xE3o pode apresentar \\xE9 em casos em que voc\\xEA queira\\narredondar alguns valores que est\\xE3o dentro \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"arrays\"), \" utilizando, por exemplo, o\\nm\\xE9todo \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"map\"), \". Caso voc\\xEA tenha uma \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"array\"), \" com \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"42.25\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"42.5\"), \" e \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"42.75\"), \" e queira\\nt\\xEA-los em uma nova \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"array\"), \" como os valores arredondados para baixo ent\\xE3o voc\\xEA\\npoderia tentar, fracassadamente, isso:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"[ 42.25, 42.5, 42.75 ].map(parseInt) // Cuidado! Isso retorna [42, NaN, NaN] e n\\xE3o [ 42, 42, 42 ]\\n\")), mdx(\"p\", null, \"Nesse caso a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"callback\"), \" do m\\xE9todo \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"map\"), \" entrega tr\\xEAs par\\xE2metros (o item, o\\n\\xEDndice e a pr\\xF3pria \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"array\"), \"), onde nesse caso o \\xEDndice do segundo argumento do\\nitem que est\\xE1 sendo processado vai entrar em conflito com a base recebida no\\nsegundo argumento do \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"parseInt\"), \". Ou seja a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"array\"), \" acima seria processada, mais\\nou menos da seguinte maneira:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"[\\n  parseInt(42.25, 0), // 42.25 = item e 0 = \\xEDndice\\n  parseInt(42.5, 1), // 42.5 = item e 1 = \\xEDndice\\n  parseInt(42.75, 2) // 42.75 = item e 2 = \\xEDndice\\n]\\n\")), mdx(\"p\", null, \"Portanto, em casos como esses e em qualquer outro caso no qual voc\\xEA queira\\narredondar valores do tipo \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Number\"), \", o mais ideal seria utilizar os m\\xE9todos do\\nobjeto \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Math\"), \", que nesse caso espec\\xEDfico seria o \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"floor\"), \".\"));\n}\n\n;\nMDXContent.isMDXComponent = true;","renderedOutput":"\u003cp\u003eO objeto \u003ccode\u003eMath\u003c/code\u003e do JavaScript possui vários métodos que permitem fazer a\nconversão de números decimais, como o \u003ccode\u003efloor\u003c/code\u003e, o \u003ccode\u003eceil\u003c/code\u003e e o \u003ccode\u003eround\u003c/code\u003e. Logo de\ncara, observa-se que todos eles fazem o mesmo serviço: receber valores\ndecimais e retornar valores inteiros. Por isso acabam confundindo algumas\npessoas, pois eles não são as mesmas funções e, portanto, trabalham de modo\ndiferente um do outro.\u003c/p\u003e\u003cp\u003eO funcionamento básico de cada um desses métodos é bem simples: um arredonda\npara o inteiro menor, outro para o inteiro maior e outro para o inteiro mais\npróximo, respectivamente. Portanto, \u003ccode\u003eMath.floor(42.6)\u003c/code\u003e é \u003ccode\u003e42\u003c/code\u003e,\n\u003ccode\u003eMath.ceil(42.6)\u003c/code\u003e é \u003ccode\u003e43\u003c/code\u003e e \u003ccode\u003eMath.round(42.6)\u003c/code\u003e é \u003ccode\u003e43\u003c/code\u003e também. No \u003ccode\u003eMath.round\u003c/code\u003e,\nquando o decimal for \u003ccode\u003e0.5\u003c/code\u003e o número vai ser arredondado para o maior inteiro\nmais próximo.\u003c/p\u003e\u003cblockquote\u003e\u003cp\u003eObserve que \u003ccode\u003eMath.floor(3.14)\u003c/code\u003e é \u003ccode\u003e3\u003c/code\u003e e \u003ccode\u003eMath.floor(-3.14)\u003c/code\u003e é \u003ccode\u003e-4\u003c/code\u003e.\u003c/p\u003e\u003c/blockquote\u003e\u003ch2\u003eTudo bem, mas e a \u0026quot;parseInt\u0026quot;?\u003c/h2\u003e\u003cp\u003eOutra função que faz algo parecido com todos esses métodos é a \u003ccode\u003eparseInt\u003c/code\u003e que\nem uma análise rápida se parece muito com o \u003ccode\u003eMath.floor\u003c/code\u003e. No entanto ela é bem\ndiferente, pois foi programada para receber strings e não números. Certo, mas\nos métodos do objeto \u003ccode\u003eMath\u003c/code\u003e também convertem \u003cem\u003estrings\u003c/em\u003e em objetos, não é? Sim,\nmas a \u003ccode\u003eparseInt\u003c/code\u003e possui algumas características diferentes, por exemplo, ela\nanalisa somente os dígitos iniciais da \u003cem\u003estring\u003c/em\u003e, onde qualquer coisa que vem\ndepois deles é desconsiderado.\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003eparseInt(\u0026#x27;42px\u0026#x27;) // Isso retorna 42\nMath.floor(\u0026#x27;42px\u0026#x27;) // Isso retorna NaN :\u0026#x27;-(\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003eProblemas de arredondar com \u0026quot;parseInt\u0026quot;\u003c/h2\u003e\u003cp\u003eOutra coisa interessante da função \u003ccode\u003eparseInt\u003c/code\u003e é que ela pode trabalhar como o\ninverso do \u003ccode\u003eNumber.toString\u003c/code\u003e, que converte um número para determinada base\nnumérica (como binário, hexadecimal, entre outros). No caso da \u003ccode\u003eparseInt\u003c/code\u003e, a\nbase deve ser informada no segundo argumento do função, por exemplo, \u0026quot;2a\u0026quot; é a\nversão hexadecimal do número 42, então se fizermos \u003ccode\u003eparseInt(\u0026#x27;2a\u0026#x27;, 16)\u003c/code\u003e\n(onde \u003ccode\u003e16\u003c/code\u003e representa \u0026quot;hexadecimal\u0026quot;) vamos obter \u003ccode\u003e42\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eUm problema que essa função pode apresentar é em casos em que você queira\narredondar alguns valores que estão dentro \u003cem\u003earrays\u003c/em\u003e utilizando, por exemplo, o\nmétodo \u003ccode\u003emap\u003c/code\u003e. Caso você tenha uma \u003cem\u003earray\u003c/em\u003e com \u003ccode\u003e42.25\u003c/code\u003e, \u003ccode\u003e42.5\u003c/code\u003e e \u003ccode\u003e42.75\u003c/code\u003e e queira\ntê-los em uma nova \u003cem\u003earray\u003c/em\u003e como os valores arredondados para baixo então você\npoderia tentar, fracassadamente, isso:\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e[ 42.25, 42.5, 42.75 ].map(parseInt) // Cuidado! Isso retorna [42, NaN, NaN] e não [ 42, 42, 42 ]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNesse caso a \u003cem\u003ecallback\u003c/em\u003e do método \u003ccode\u003emap\u003c/code\u003e entrega três parâmetros (o item, o\níndice e a própria \u003cem\u003earray\u003c/em\u003e), onde nesse caso o índice do segundo argumento do\nitem que está sendo processado vai entrar em conflito com a base recebida no\nsegundo argumento do \u003ccode\u003eparseInt\u003c/code\u003e. Ou seja a \u003cem\u003earray\u003c/em\u003e acima seria processada, mais\nou menos da seguinte maneira:\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e[\n  parseInt(42.25, 0), // 42.25 = item e 0 = índice\n  parseInt(42.5, 1), // 42.5 = item e 1 = índice\n  parseInt(42.75, 2) // 42.75 = item e 2 = índice\n]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003ePortanto, em casos como esses e em qualquer outro caso no qual você queira\narredondar valores do tipo \u003ccode\u003eNumber\u003c/code\u003e, o mais ideal seria utilizar os métodos do\nobjeto \u003ccode\u003eMath\u003c/code\u003e, que nesse caso específico seria o \u003ccode\u003efloor\u003c/code\u003e.\u003c/p\u003e","scope":{"title":"Arredondando números com JavaScript","date":"2018-12-17"}},"frontMatter":{"title":"Arredondando números com JavaScript","date":"2018-12-17"}},"__N_SSG":true},"page":"/blog/[post]","query":{"post":"arredondando-numeros-com-javascript"},"buildId":"_Vefdb0nBAV0M8rnMBEiN","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-81bd132d8cf44e5a14d7.js"></script><script src="/_next/static/chunks/main-12c069fcb26ee750200e.js" async=""></script><script src="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" async=""></script><script src="/_next/static/chunks/framework.abffcf18e526b7c0dbcd.js" async=""></script><script src="/_next/static/chunks/1b1d2efccfda2790dd424b9455d4bf69d97f9eaa.10b20fed2722a467a0a9.js" async=""></script><script src="/_next/static/chunks/f6078781a05fe1bcb0902d23dbbb2662c8d200b3.22385a4a605b66265c77.js" async=""></script><script src="/_next/static/chunks/pages/_app-98df5063b029dd539922.js" async=""></script><script src="/_next/static/chunks/pages/blog/%5Bpost%5D-27b6e4167a38e98f672f.js" async=""></script><script src="/_next/static/_Vefdb0nBAV0M8rnMBEiN/_buildManifest.js" async=""></script><script src="/_next/static/_Vefdb0nBAV0M8rnMBEiN/_ssgManifest.js" async=""></script></body></html>