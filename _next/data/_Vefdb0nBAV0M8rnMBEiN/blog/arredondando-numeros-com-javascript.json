{"pageProps":{"source":{"compiledSource":"\"use strict\";\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\n\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"O objeto \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Math\"), \" do JavaScript possui v\\xE1rios m\\xE9todos que permitem fazer a\\nconvers\\xE3o de n\\xFAmeros decimais, como o \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"floor\"), \", o \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ceil\"), \" e o \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"round\"), \". Logo de\\ncara, observa-se que todos eles fazem o mesmo servi\\xE7o: receber valores\\ndecimais e retornar valores inteiros. Por isso acabam confundindo algumas\\npessoas, pois eles n\\xE3o s\\xE3o as mesmas fun\\xE7\\xF5es e, portanto, trabalham de modo\\ndiferente um do outro.\"), mdx(\"p\", null, \"O funcionamento b\\xE1sico de cada um desses m\\xE9todos \\xE9 bem simples: um arredonda\\npara o inteiro menor, outro para o inteiro maior e outro para o inteiro mais\\npr\\xF3ximo, respectivamente. Portanto, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Math.floor(42.6)\"), \" \\xE9 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"42\"), \",\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Math.ceil(42.6)\"), \" \\xE9 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"43\"), \" e \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Math.round(42.6)\"), \" \\xE9 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"43\"), \" tamb\\xE9m. No \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Math.round\"), \",\\nquando o decimal for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0.5\"), \" o n\\xFAmero vai ser arredondado para o maior inteiro\\nmais pr\\xF3ximo.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Observe que \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Math.floor(3.14)\"), \" \\xE9 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"3\"), \" e \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Math.floor(-3.14)\"), \" \\xE9 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"-4\"), \".\")), mdx(\"h2\", null, \"Tudo bem, mas e a \\\"parseInt\\\"?\"), mdx(\"p\", null, \"Outra fun\\xE7\\xE3o que faz algo parecido com todos esses m\\xE9todos \\xE9 a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"parseInt\"), \" que\\nem uma an\\xE1lise r\\xE1pida se parece muito com o \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Math.floor\"), \". No entanto ela \\xE9 bem\\ndiferente, pois foi programada para receber strings e n\\xE3o n\\xFAmeros. Certo, mas\\nos m\\xE9todos do objeto \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Math\"), \" tamb\\xE9m convertem \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"strings\"), \" em objetos, n\\xE3o \\xE9? Sim,\\nmas a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"parseInt\"), \" possui algumas caracter\\xEDsticas diferentes, por exemplo, ela\\nanalisa somente os d\\xEDgitos iniciais da \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"string\"), \", onde qualquer coisa que vem\\ndepois deles \\xE9 desconsiderado.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"parseInt('42px') // Isso retorna 42\\nMath.floor('42px') // Isso retorna NaN :'-(\\n\")), mdx(\"h2\", null, \"Problemas de arredondar com \\\"parseInt\\\"\"), mdx(\"p\", null, \"Outra coisa interessante da fun\\xE7\\xE3o \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"parseInt\"), \" \\xE9 que ela pode trabalhar como o\\ninverso do \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Number.toString\"), \", que converte um n\\xFAmero para determinada base\\nnum\\xE9rica (como bin\\xE1rio, hexadecimal, entre outros). No caso da \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"parseInt\"), \", a\\nbase deve ser informada no segundo argumento do fun\\xE7\\xE3o, por exemplo, \\\"2a\\\" \\xE9 a\\nvers\\xE3o hexadecimal do n\\xFAmero 42, ent\\xE3o se fizermos \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"parseInt('2a', 16)\"), \"\\n(onde \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"16\"), \" representa \\\"hexadecimal\\\") vamos obter \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"42\"), \".\"), mdx(\"p\", null, \"Um problema que essa fun\\xE7\\xE3o pode apresentar \\xE9 em casos em que voc\\xEA queira\\narredondar alguns valores que est\\xE3o dentro \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"arrays\"), \" utilizando, por exemplo, o\\nm\\xE9todo \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"map\"), \". Caso voc\\xEA tenha uma \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"array\"), \" com \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"42.25\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"42.5\"), \" e \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"42.75\"), \" e queira\\nt\\xEA-los em uma nova \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"array\"), \" como os valores arredondados para baixo ent\\xE3o voc\\xEA\\npoderia tentar, fracassadamente, isso:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"[ 42.25, 42.5, 42.75 ].map(parseInt) // Cuidado! Isso retorna [42, NaN, NaN] e n\\xE3o [ 42, 42, 42 ]\\n\")), mdx(\"p\", null, \"Nesse caso a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"callback\"), \" do m\\xE9todo \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"map\"), \" entrega tr\\xEAs par\\xE2metros (o item, o\\n\\xEDndice e a pr\\xF3pria \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"array\"), \"), onde nesse caso o \\xEDndice do segundo argumento do\\nitem que est\\xE1 sendo processado vai entrar em conflito com a base recebida no\\nsegundo argumento do \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"parseInt\"), \". Ou seja a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"array\"), \" acima seria processada, mais\\nou menos da seguinte maneira:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"[\\n  parseInt(42.25, 0), // 42.25 = item e 0 = \\xEDndice\\n  parseInt(42.5, 1), // 42.5 = item e 1 = \\xEDndice\\n  parseInt(42.75, 2) // 42.75 = item e 2 = \\xEDndice\\n]\\n\")), mdx(\"p\", null, \"Portanto, em casos como esses e em qualquer outro caso no qual voc\\xEA queira\\narredondar valores do tipo \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Number\"), \", o mais ideal seria utilizar os m\\xE9todos do\\nobjeto \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Math\"), \", que nesse caso espec\\xEDfico seria o \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"floor\"), \".\"));\n}\n\n;\nMDXContent.isMDXComponent = true;","renderedOutput":"<p>O objeto <code>Math</code> do JavaScript possui vários métodos que permitem fazer a\nconversão de números decimais, como o <code>floor</code>, o <code>ceil</code> e o <code>round</code>. Logo de\ncara, observa-se que todos eles fazem o mesmo serviço: receber valores\ndecimais e retornar valores inteiros. Por isso acabam confundindo algumas\npessoas, pois eles não são as mesmas funções e, portanto, trabalham de modo\ndiferente um do outro.</p><p>O funcionamento básico de cada um desses métodos é bem simples: um arredonda\npara o inteiro menor, outro para o inteiro maior e outro para o inteiro mais\npróximo, respectivamente. Portanto, <code>Math.floor(42.6)</code> é <code>42</code>,\n<code>Math.ceil(42.6)</code> é <code>43</code> e <code>Math.round(42.6)</code> é <code>43</code> também. No <code>Math.round</code>,\nquando o decimal for <code>0.5</code> o número vai ser arredondado para o maior inteiro\nmais próximo.</p><blockquote><p>Observe que <code>Math.floor(3.14)</code> é <code>3</code> e <code>Math.floor(-3.14)</code> é <code>-4</code>.</p></blockquote><h2>Tudo bem, mas e a &quot;parseInt&quot;?</h2><p>Outra função que faz algo parecido com todos esses métodos é a <code>parseInt</code> que\nem uma análise rápida se parece muito com o <code>Math.floor</code>. No entanto ela é bem\ndiferente, pois foi programada para receber strings e não números. Certo, mas\nos métodos do objeto <code>Math</code> também convertem <em>strings</em> em objetos, não é? Sim,\nmas a <code>parseInt</code> possui algumas características diferentes, por exemplo, ela\nanalisa somente os dígitos iniciais da <em>string</em>, onde qualquer coisa que vem\ndepois deles é desconsiderado.</p><pre><code class=\"language-javascript\">parseInt(&#x27;42px&#x27;) // Isso retorna 42\nMath.floor(&#x27;42px&#x27;) // Isso retorna NaN :&#x27;-(\n</code></pre><h2>Problemas de arredondar com &quot;parseInt&quot;</h2><p>Outra coisa interessante da função <code>parseInt</code> é que ela pode trabalhar como o\ninverso do <code>Number.toString</code>, que converte um número para determinada base\nnumérica (como binário, hexadecimal, entre outros). No caso da <code>parseInt</code>, a\nbase deve ser informada no segundo argumento do função, por exemplo, &quot;2a&quot; é a\nversão hexadecimal do número 42, então se fizermos <code>parseInt(&#x27;2a&#x27;, 16)</code>\n(onde <code>16</code> representa &quot;hexadecimal&quot;) vamos obter <code>42</code>.</p><p>Um problema que essa função pode apresentar é em casos em que você queira\narredondar alguns valores que estão dentro <em>arrays</em> utilizando, por exemplo, o\nmétodo <code>map</code>. Caso você tenha uma <em>array</em> com <code>42.25</code>, <code>42.5</code> e <code>42.75</code> e queira\ntê-los em uma nova <em>array</em> como os valores arredondados para baixo então você\npoderia tentar, fracassadamente, isso:</p><pre><code class=\"language-javascript\">[ 42.25, 42.5, 42.75 ].map(parseInt) // Cuidado! Isso retorna [42, NaN, NaN] e não [ 42, 42, 42 ]\n</code></pre><p>Nesse caso a <em>callback</em> do método <code>map</code> entrega três parâmetros (o item, o\níndice e a própria <em>array</em>), onde nesse caso o índice do segundo argumento do\nitem que está sendo processado vai entrar em conflito com a base recebida no\nsegundo argumento do <code>parseInt</code>. Ou seja a <em>array</em> acima seria processada, mais\nou menos da seguinte maneira:</p><pre><code class=\"language-javascript\">[\n  parseInt(42.25, 0), // 42.25 = item e 0 = índice\n  parseInt(42.5, 1), // 42.5 = item e 1 = índice\n  parseInt(42.75, 2) // 42.75 = item e 2 = índice\n]\n</code></pre><p>Portanto, em casos como esses e em qualquer outro caso no qual você queira\narredondar valores do tipo <code>Number</code>, o mais ideal seria utilizar os métodos do\nobjeto <code>Math</code>, que nesse caso específico seria o <code>floor</code>.</p>","scope":{"title":"Arredondando números com JavaScript","date":"2018-12-17"}},"frontMatter":{"title":"Arredondando números com JavaScript","date":"2018-12-17"}},"__N_SSG":true}