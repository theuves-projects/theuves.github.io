{"pageProps":{"source":{"compiledSource":"\"use strict\";\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\n\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Certa vez, quando comecei estudar JavaScript, decidi criar uma\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/theuves/extenso.js\"\n  }), \"ferramenta para escrever n\\xFAmeros por extenso\"), \"\\nna l\\xEDngua portuguesa. Tal ferramenta deveria escrever valores altos: at\\xE9 999\\ndecilh\\xF5es.\"), mdx(\"p\", null, \"No entanto, enfrentei problemas logo quando tentei realizar os testes\\nunit\\xE1rios, onde em um momento, eu passava \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"10000000000000001\"), \" (em \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Number\"), \")\\ncomo entrada e esperava ter, portanto, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"'dez quatrilh\\xF5es e um'\"), \" como sa\\xEDda. Mas\\ntinha algo errado e eu s\\xF3 recebia \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"'dez quatrilh\\xF5es'\"), \". Revirei todo o meu\\nc\\xF3digo a procura do erro, mas s\\xF3 ap\\xF3s um bom tempo descobri que o \\\"problema\\\"\\nestava fora dele: no pr\\xF3prio JavaScript.\"), mdx(\"p\", null, \"O fato \\xE9 que a linguagem armazena os seus valores num\\xE9ricos em 64 bits seguindo\\no \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.youtube.com/watch?v=PDgT0T0Yodo\"\n  }), \"padr\\xE3o internacional IEEE 754\"), \"\\ncujo o maior n\\xFAmero inteiro com uma precis\\xE3o segura \\xE9 9.007.199.254.740.991\\n(cerca de 9 quatrilh\\xF5es), onde qualquer n\\xFAmero maior que esse pode ter valores\\nperdidos, sendo assim, inseguros. Visto que nos meus testes eu estava passando\\num valor maior que esse e como um \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Number\"), \" do JavaScript, eu tinha finalmente\\nencontrado o motivo do erro.\"), mdx(\"h2\", null, \"Resolvendo o problema com \", mdx(\"inlineCode\", {\n    parentName: \"h2\"\n  }, \"BigInt\")), mdx(\"p\", null, \"Okay, ent\\xE3o n\\xE3o podemos confiar em opera\\xE7\\xF5es matem\\xE1ticas com n\\xFAmeros grandes\\nno JavaScript pois eles ser\\xE3o registrados de modo diferente? Sim, mas s\\xF3 por\\nenquanto. Na \\xE9poca em que eu estava fazendo minha ferramenta, n\\xE3o existia\\nnenhuma proposta de solu\\xE7\\xE3o para isso, al\\xE9m de bibliotecas que deixam o sistema\\nlento e o desenvolvimento chato. At\\xE9 que\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://twitter.com/littledan\"\n  }), \"Daniel Ehrenberg\"), \" publicou sua proposta de\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"BigInt\"), \", um novo tipo de dado que tem como objetivo dar a possibilidade de\\nmanipular n\\xFAmeros grandes.\"), mdx(\"p\", null, \"A ideia \\xE9 simples: representar n\\xFAmeros inteiros de qualquer tamanho utilizando\\num \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"n\"), \" no final ou dentro de \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"strings\"), \" envolvidas no objeto \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"BigInt\"), \". Sendo\\nassim, se antes \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"10000000000000001\"), \" estranhamente virava  \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"10000000000000000\"), \",\\nagora bastaria usar \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"10000000000000001n\"), \" e o n\\xFAmero n\\xE3o teria nenhuma altera\\xE7\\xE3o.\"), mdx(\"h2\", null, \"Funcionamento\"), mdx(\"p\", null, \"O \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"BigInt\"), \" tem o seu pr\\xF3prio tipo, onde \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"typeof 42n\"), \" \\xE9 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"'bigint'\"), \" e n\\xE3o\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"'number'\"), \". \"), mdx(\"p\", null, \"Os \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"BigInt\"), \"s s\\xE3o bastante semelhantes aos \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Number\"), \"s, podendo ser feita as\\nmesmas opera\\xE7\\xF5es matem\\xE1ticas com \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"+\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"-\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"*\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"/\"), \", etc. Contudo, embora eles\\nsejam parecidos, opera\\xE7\\xF5es entre um e outro \\xE9 completamente imposs\\xEDvel, o que\\nsignifica que voc\\xEA jamais poder\\xE1 fazer coisas como \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"6n * 2\"), \", pois isso causaria\\num \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TypeError\"), \". Al\\xE9m disso, assim como o pr\\xF3prio nome \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"BigInt\"), \" sugere, o novo\\ntipo s\\xF3 pode trabalhar com n\\xFAmeros inteiros, onde qualquer resultado quebrado\\nem opera\\xE7\\xF5es ser\\xE1 arredondado automaticamente.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"console.log(5n / 2n) // Isso retorna 2n e n\\xE3o 2.5n.\\n\")), mdx(\"p\", null, \"Observa-se tamb\\xE9m que \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"2.5n\"), \" n\\xE3o existe, sendo um \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SyntaxError\"), \".\"), mdx(\"p\", null, \"Outra  semelhan\\xE7a interessante com o \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Number\"), \" \\xE9 a possibilidade da manipula\\xE7\\xE3o\\nde n\\xFAmeros como se fossem valores booleanos, por exemplo, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Boolean(0n)\"), \" quem \\xE9\\nigual a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"false\"), \", enquanto qualquer outro n\\xFAmero diferente de zero \\xE9 verdadeiro.\"), mdx(\"h2\", null, \"J\\xE1 posso us\\xE1-lo em projetos?\"), mdx(\"p\", null, \"No momento (final de 2018) a proposta do \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"BigInt\"), \" j\\xE1 est\\xE1 no est\\xE1gio tr\\xEAs,\\nprecisando estar no quatro para ser um novo padr\\xE3o da linguagem (veja\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://medium.com/@brunovincius/processo-de-adi%C3%A7%C3%A3o-de-novas-features-do-js-5c2e086cab8f\"\n  }), \"esse post\"), \"\\ndo Bruno Vin\\xEDcius sobre os est\\xE1gios das futuras caracter\\xEDsticas do JavaScript),\\nmas falta muito pouco para que ele chegue l\\xE1, portanto, provavelmente em 2019\\nou 2020 ele j\\xE1 estar\\xE1 padronizado.\"), mdx(\"p\", null, \"Caso voc\\xEA j\\xE1 queira test\\xE1-lo na pr\\xE1tica, pode faz\\xEA-lo com as \\xFAltimas vers\\xF5es do\\nGoogle Chrome (que o aceita\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://developers.google.com/web/updates/2018/05/nic67\"\n  }), \"desde maio desse ano\"), \"),\\ndo Opera e do Node.js. No momento o Mozilla Firefox ainda n\\xE3o o suporta, mas \\xE9\\nposs\\xEDvel que em breve tamb\\xE9m vai aceit\\xE1-lo.\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://caniuse.com/#feat=bigint\"\n  }), \"Veja aqui como anda a compatibilidade em navegadores da \", mdx(\"em\", {\n    parentName: \"a\"\n  }, \"internet\")), \".\"), mdx(\"p\", null, \"Como ele ainda \\xE9 muito pouco suportado, caso voc\\xEA queira trabalhar com n\\xFAmero\\ngrandes em algum projeto, o mais recomendado seria usar algum\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://pt.stackoverflow.com/questions/194857/o-que-%C3%A9-polyfill\"\n  }), mdx(\"em\", {\n    parentName: \"a\"\n  }, \"polyfill\")), \".\\nH\\xE1 muito tempo j\\xE1 existe bibliotecas como \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.npmjs.com/package/bn.js\"\n  }), mdx(\"em\", {\n    parentName: \"a\"\n  }, \"bn.js\")), \"\\nque trabalham com m\\xE9todos para fazer opera\\xE7\\xF5es com n\\xFAmeros desse tipo dentro\\nde \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"strings\"), \", por\\xE9m, elas s\\xE3o lentas e impossibilitam o uso da nota\\xE7\\xE3o \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"n\"), \" no\\nfinal dos n\\xFAmeros, o que torna o desenvolvimento desagrad\\xE1vel.\"), mdx(\"p\", null, \"A biblioteca mais interessante no momento \\xE9 a\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.npmjs.com/package/jsbi\"\n  }), mdx(\"em\", {\n    parentName: \"a\"\n  }, \"JSBI\")), \" lan\\xE7ada h\\xE1 pouco tempo pela galera\\ndo Google Chrome Labs. Ela basicamente oferece um objeto que pode ser usado\\npara fazer todas opera\\xE7\\xF5es que o \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"BigInt\"), \" poder\\xE1 fazer.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"import JSBI from 'jsbi'\\n\\nconst x = JSBI.BigInt('10000000000000000')\\nconst y = JSBI.BigInt('1')\\nconst result = JSBI.add(x, y)\\n\\nconsole.log(result.toString()) // Meu '10000000000000001', finalmente!\\n\")), mdx(\"p\", null, \"O mais curioso tamb\\xE9m, \\xE9 o \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"plugin\"), \"\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.npmjs.com/package/babel-plugin-transform-jsbi-to-bigint\"\n  }), mdx(\"em\", {\n    parentName: \"a\"\n  }, \"babel-plugin-transform-jsbi-to-bigint\")), \"\\npara o Babel que foi lan\\xE7ado junto com essa biblioteca. Esse \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"plugin\"), \" permite\\nque em futuro pr\\xF3ximo, quando \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"BigInt\"), \"s forem nativas do JavaScript, voc\\xEA possa\\nconverter o seu c\\xF3digo que faz opera\\xE7\\xF5es com \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"JSBI\"), \" para \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"BigInt\"), \", ou seja,\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"JSBI.BigInt('10000000000000000')\"), \" seria transformado em \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"10000000000000000n\"), \".\\nCaso queira testar isso, eu deixei\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/theuves-demos/jsbi-to-bigint\"\n  }), \"esse reposit\\xF3rio\"), \" no GitHub\\ncom um exemplo.\"), mdx(\"p\", null, \"Se voc\\xEA deseja saber mais sobre o funcionamento dessa nova \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"feature\"), \", eu\\nrecomendo que voc\\xEA veja a\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/tc39/proposal-bigint\"\n  }), \"proposta dela no GitHub\"), \" (em ingl\\xEAs)\\ne assista a palestra\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.youtube.com/watch?v=RiU5OzMZ7z8\"\n  }), mdx(\"em\", {\n    parentName: \"a\"\n  }, \"Native BigInts in JavaScript: A Case Study in TC39\")), \"\\n(em ingl\\xEAs tamb\\xE9m) do pr\\xF3prio autor Daniel Ehrenberg na JSConf 2018.\"));\n}\n\n;\nMDXContent.isMDXComponent = true;","renderedOutput":"<p>Certa vez, quando comecei estudar JavaScript, decidi criar uma\n<a href=\"https://github.com/theuves/extenso.js\">ferramenta para escrever números por extenso</a>\nna língua portuguesa. Tal ferramenta deveria escrever valores altos: até 999\ndecilhões.</p><p>No entanto, enfrentei problemas logo quando tentei realizar os testes\nunitários, onde em um momento, eu passava <code>10000000000000001</code> (em <code>Number</code>)\ncomo entrada e esperava ter, portanto, <code>&#x27;dez quatrilhões e um&#x27;</code> como saída. Mas\ntinha algo errado e eu só recebia <code>&#x27;dez quatrilhões&#x27;</code>. Revirei todo o meu\ncódigo a procura do erro, mas só após um bom tempo descobri que o &quot;problema&quot;\nestava fora dele: no próprio JavaScript.</p><p>O fato é que a linguagem armazena os seus valores numéricos em 64 bits seguindo\no <a href=\"https://www.youtube.com/watch?v=PDgT0T0Yodo\">padrão internacional IEEE 754</a>\ncujo o maior número inteiro com uma precisão segura é 9.007.199.254.740.991\n(cerca de 9 quatrilhões), onde qualquer número maior que esse pode ter valores\nperdidos, sendo assim, inseguros. Visto que nos meus testes eu estava passando\num valor maior que esse e como um <code>Number</code> do JavaScript, eu tinha finalmente\nencontrado o motivo do erro.</p><h2>Resolvendo o problema com <code>BigInt</code></h2><p>Okay, então não podemos confiar em operações matemáticas com números grandes\nno JavaScript pois eles serão registrados de modo diferente? Sim, mas só por\nenquanto. Na época em que eu estava fazendo minha ferramenta, não existia\nnenhuma proposta de solução para isso, além de bibliotecas que deixam o sistema\nlento e o desenvolvimento chato. Até que\n<a href=\"https://twitter.com/littledan\">Daniel Ehrenberg</a> publicou sua proposta de\n<code>BigInt</code>, um novo tipo de dado que tem como objetivo dar a possibilidade de\nmanipular números grandes.</p><p>A ideia é simples: representar números inteiros de qualquer tamanho utilizando\num <code>n</code> no final ou dentro de <em>strings</em> envolvidas no objeto <code>BigInt</code>. Sendo\nassim, se antes <code>10000000000000001</code> estranhamente virava  <code>10000000000000000</code>,\nagora bastaria usar <code>10000000000000001n</code> e o número não teria nenhuma alteração.</p><h2>Funcionamento</h2><p>O <code>BigInt</code> tem o seu próprio tipo, onde <code>typeof 42n</code> é <code>&#x27;bigint&#x27;</code> e não\n<code>&#x27;number&#x27;</code>. </p><p>Os <code>BigInt</code>s são bastante semelhantes aos <code>Number</code>s, podendo ser feita as\nmesmas operações matemáticas com <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, etc. Contudo, embora eles\nsejam parecidos, operações entre um e outro é completamente impossível, o que\nsignifica que você jamais poderá fazer coisas como <code>6n * 2</code>, pois isso causaria\num <code>TypeError</code>. Além disso, assim como o próprio nome <code>BigInt</code> sugere, o novo\ntipo só pode trabalhar com números inteiros, onde qualquer resultado quebrado\nem operações será arredondado automaticamente.</p><pre><code class=\"language-js\">console.log(5n / 2n) // Isso retorna 2n e não 2.5n.\n</code></pre><p>Observa-se também que <code>2.5n</code> não existe, sendo um <code>SyntaxError</code>.</p><p>Outra  semelhança interessante com o <code>Number</code> é a possibilidade da manipulação\nde números como se fossem valores booleanos, por exemplo, <code>Boolean(0n)</code> quem é\nigual a <code>false</code>, enquanto qualquer outro número diferente de zero é verdadeiro.</p><h2>Já posso usá-lo em projetos?</h2><p>No momento (final de 2018) a proposta do <code>BigInt</code> já está no estágio três,\nprecisando estar no quatro para ser um novo padrão da linguagem (veja\n<a href=\"https://medium.com/@brunovincius/processo-de-adi%C3%A7%C3%A3o-de-novas-features-do-js-5c2e086cab8f\">esse post</a>\ndo Bruno Vinícius sobre os estágios das futuras características do JavaScript),\nmas falta muito pouco para que ele chegue lá, portanto, provavelmente em 2019\nou 2020 ele já estará padronizado.</p><p>Caso você já queira testá-lo na prática, pode fazê-lo com as últimas versões do\nGoogle Chrome (que o aceita\n<a href=\"https://developers.google.com/web/updates/2018/05/nic67\">desde maio desse ano</a>),\ndo Opera e do Node.js. No momento o Mozilla Firefox ainda não o suporta, mas é\npossível que em breve também vai aceitá-lo.\n<a href=\"https://caniuse.com/#feat=bigint\">Veja aqui como anda a compatibilidade em navegadores da <em>internet</em></a>.</p><p>Como ele ainda é muito pouco suportado, caso você queira trabalhar com número\ngrandes em algum projeto, o mais recomendado seria usar algum\n<a href=\"https://pt.stackoverflow.com/questions/194857/o-que-%C3%A9-polyfill\"><em>polyfill</em></a>.\nHá muito tempo já existe bibliotecas como <a href=\"https://www.npmjs.com/package/bn.js\"><em>bn.js</em></a>\nque trabalham com métodos para fazer operações com números desse tipo dentro\nde <em>strings</em>, porém, elas são lentas e impossibilitam o uso da notação <code>n</code> no\nfinal dos números, o que torna o desenvolvimento desagradável.</p><p>A biblioteca mais interessante no momento é a\n<a href=\"https://www.npmjs.com/package/jsbi\"><em>JSBI</em></a> lançada há pouco tempo pela galera\ndo Google Chrome Labs. Ela basicamente oferece um objeto que pode ser usado\npara fazer todas operações que o <code>BigInt</code> poderá fazer.</p><pre><code class=\"language-js\">import JSBI from &#x27;jsbi&#x27;\n\nconst x = JSBI.BigInt(&#x27;10000000000000000&#x27;)\nconst y = JSBI.BigInt(&#x27;1&#x27;)\nconst result = JSBI.add(x, y)\n\nconsole.log(result.toString()) // Meu &#x27;10000000000000001&#x27;, finalmente!\n</code></pre><p>O mais curioso também, é o <em>plugin</em>\n<a href=\"https://www.npmjs.com/package/babel-plugin-transform-jsbi-to-bigint\"><em>babel-plugin-transform-jsbi-to-bigint</em></a>\npara o Babel que foi lançado junto com essa biblioteca. Esse <em>plugin</em> permite\nque em futuro próximo, quando <code>BigInt</code>s forem nativas do JavaScript, você possa\nconverter o seu código que faz operações com <em>JSBI</em> para <em>BigInt</em>, ou seja,\n<code>JSBI.BigInt(&#x27;10000000000000000&#x27;)</code> seria transformado em <code>10000000000000000n</code>.\nCaso queira testar isso, eu deixei\n<a href=\"https://github.com/theuves-demos/jsbi-to-bigint\">esse repositório</a> no GitHub\ncom um exemplo.</p><p>Se você deseja saber mais sobre o funcionamento dessa nova <em>feature</em>, eu\nrecomendo que você veja a\n<a href=\"https://github.com/tc39/proposal-bigint\">proposta dela no GitHub</a> (em inglês)\ne assista a palestra\n<a href=\"https://www.youtube.com/watch?v=RiU5OzMZ7z8\"><em>Native BigInts in JavaScript: A Case Study in TC39</em></a>\n(em inglês também) do próprio autor Daniel Ehrenberg na JSConf 2018.</p>","scope":{"title":"Números grandes em JavaScript com BigInt","date":"2018-12-16"}},"frontMatter":{"title":"Números grandes em JavaScript com BigInt","date":"2018-12-16"}},"__N_SSG":true}